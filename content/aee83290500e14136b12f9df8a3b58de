<html><head><!-- This document was created from RTF source by rtftohtml version
2.7.5 and manual conversion by Charles Lloyd clloyd@giantleap.com --><title>How to use Model-View-Controller (MVC)</title></head><body>
<a href=/><img src=/users/smarch/pics/smalltalk-archive.gif
alt="[Smalltalk Archive]" border=0></a>
<a href=/research-gp.html><img src=/users/smarch/pics/research-group.gif
alt="[Research Group]" border=0></a>
<a href=/users/chai/locator.html><img src=/users/smarch/pics/contact-ian.gif alt="[Contact Ian]" border=0></a>
<a href=/users/chai/main.html><img src=/users/smarch/pics/home.gif alt="[Ian's Home]" border=0></a>
<a href="ftp://st.cs.uiuc.edu/pub/Smalltalk/st-docs/mvc.rtf"><img src=mvc-button.gif border=0 alt="[Original RTF of this document]"></a>
<h1><CENTER>Applications Programming in Smalltalk-80(TM):<br>
How to use Model-View-Controller (MVC)</CENTER></h1>
<CENTER>by<br>
Steve Burbeck, Ph.D.</CENTER>
<p>
<I>Author's note:  This paper originally described the MVC framework as it existed
in Smalltalk-80 v2.0.  It was updated in 1992 to take into account the changes
made for Smalltalk-80 v2.5.   ParcPlace made extensive changes to the
mechanisms for versions 4.x that are not reflected in this paper.</I>

<p>

<TT>Copyright (c) 1987, 1992 by S. Burbeck<br>permission to copy for educational or
non-commercial purposes is hereby granted<p>
(TM)Smalltalk-80 is a trademark of ParcPlace Systems, Inc.</TT><p>
<p>
<H2><CENTER>Introduction</CENTER></H2><p>
<p>
One of the contributions of Xerox PARC to the art of programming is the
multiwindowed highly interactive Smalltalk-80 interface.  This type of
interface has since been borrowed by the developers of the Apple Lisa and
Macintosh and, in turn,  by the Macintosh's many imitators.  In such an
interface, input is primarily by mouse and output is a mix of graphic and
textual components as appropriate.  The central concept behind the Smalltalk-80
user interface is the <i> Model-View-Controller</i> (MVC) paradigm.  It is
elegant and simple, but quite unlike  the approach of traditional application
programs.  Because of its novelty, it requires some explanation -- explanation
which is not readily available in published Smalltalk-80 references.<p>
<p>
If you run the graphics example in class <i>Pen</i>, you might well wonder why
this "application" draws directly on the screen rather than in a window like
the browsers, workspaces, or transcripts with which you are familiar.
Certainly you would wish your own applications to share space on the display
with the easy aplomb of a workspace rather than simply overwrite the screen.
Just what is the difference?  Most simply put, ill behaved applications do not
conform to the MVC paradigm, whereas the familiar well behaved applications
do.<p>
<p>
This paper is intended to provide the information essential for new
Smalltalk-80 programmers to begin using MVC techniques in their own programs.
Here we will introduce the mechanisms of MVC.  Once you have digested this
introduction you can strike out on your own.  You will need to flesh out the
information given here by looking at the way familiar kinds of views and
controllers -- such as workspaces, browsers and file lists -- are set up.
Browse early and often.  Remember, this is Smalltalk-80.  You are encouraged to
copy.  Start your own window by copying one that is similar to the one you want
to create.  Then modify it.  Don't be shy.  Feel free to stand on the shoulders
of the many programmers who htridave contributed to the Smalltalk-80 V2.5 image.
In a very real way, it is their gift to you.<p>
<H2><CENTER>Basic Concepts</CENTER></H2>
<p>
<p>
In the MVC paradigm the user input, the modeling of the external world,
and the visual feedback to the user are explicitly separated and handled by
three types of object, each specialized for its task.  The <b>view</b> manages
the graphical and/or textual output to the portion of the bitmapped display
that is allocated to its application.  The <b>controller</b> interprets the
mouse and keyboard inputs from the user, commanding the model and/or the view
to change as appropriate.  Finally, the <b>model</b> manages the behavior and
data of the application domain, responds to requests for information about its
state (usually from the view), and responds to instructions to change state
(usually from the controller).   The formal separation of these three tasks is
an important notion that is particularly suited to Smalltalk-80 where the basic
behavior can be embodied in abstract objects: <i>View</i>, <i>Controller,
Model</i> and <i>Object</i>.  The MVC behavior is then inherited, added to, and
modified as necessary to provide a flexible and powerful system.<p>
<p>
To use the MVC paradigm effectively you must understand the division of labor
within the MVC triad.   You also must understand how the three parts of the
triad communicate with each other and with other active views and controllers;
the sharing of a single mouse, keybord and display screen among several
applications demands communication and cooperation.  To make the best use of
the MVC paradigm you need also to learn about the available subclasses of
<i>View</i> and <i>Controller</i> which provide ready made starting points for
your applications.<p>
<p>
In Smalltalk-80, input and output are largely stylized.  Views must manage
screen real estate and display text or graphic forms within that real estate.
Controllers must cooperate to ensure that the proper controller is interpreting
keyboard and mouse input (usually according to which view contains the cursor).
Because the input and output behavior of most applications is stylized, much of
it is inherited from the generic classes -- <i>View</i> and <i>Controller</i>.
<i> </i>  These two classes, together with their subclasses, provide such a
rich variety of behavior that your applications will usually require little
added protocol to accomplish their command input and interactive output
behavior.  In contrast, the model cannot be stylized.  Constraints on the type
of objects allowed to function as models would limit the useful range of
applications possible within the MVC paradigm.  Necessarily, any object <i> </i>can be a model.<i>  </i>A float number could be the model for an
airspeed view which might be a subview of a more complex flight simulator
instrument panel view.  A <i>String</i> makes a perfectly usable model for an
editor application (although a slightly more complex object called a
<i>StringHolder</i> is usually used for such purposes).  Because any object can
play the role of model, the basic behavior required for models to participate
in the MVC paradigm is inherited from class <i>Object</i>  which is the class
that is a superclass of all possible models.<p>
<H2><CENTER>Communication Within The MVC Triad</CENTER></H2>
<p>
<p>
The model, the view and the controller involved in the MVC triad must
communicate with each other if an application is to manage a coherent
interaction with the user.  Communication between a view and its associated
controller is straightforward because <i>View</i> and <i>Controller </i>are
specifically designed to work together.  Models, on the other hand, communicate
in a more subtle manner.<p>
<p>
<H3>The Passive Model</H3>
<p>
<p>
In the simplest case, it is not necessary for a  model to make any
provision whatever for participation in an MVC triad.  A simple WYSIWYG text
editor is a good example.  The central property of such an editor is that you
should always see the text as it would appear on paper.  So the view clearly
must be informed of each change to the text so that it can update its display.
Yet the model (which we will assume is an instance of <i>String</i>) need not
take responsibility for communicating the changes to the view because these
changes occur only by requests from the user.  The controller can assume
responsibility for notifying the view of any changes because it interprets the
user's requests.  It could simply notify the view that something has changed --
the view could then request the current state of the string from its model --
or the controller could specify to the view what has changed.  In either case,
the string model is a completely passive holder of the string data manipulated
by the view and the controller.  It  adds, removes, or replaces substrings upon
demand from the controller and regurgitates appropriate substrings upon request
from the view.  The model is totally "unaware" of the existence of either the
view or the controller and of its participation in an MVC triad.  That
isolation is not an artifact of the simplicity of the model, but of the fact
that the model changes only at the behest of one of the other members of the
triad.<p>
<p>
<H3>The Model's Link to the Triad</H3>
<p>
<p>
But all models cannot be so passive.  Suppose that the data object -- the
string in the above example -- changes as a result of messages from objects
other than its view or controller.  For instance, substrings could be appended
to the end of the string as is the case with the SystemTranscript.  In that
case the object which depends upon the model's state -- its view -- must  be
notified that the model has changed.  Because only the model can track all
changes to its state, the model must have some communication link to the view.
To fill this need, a global mechanism in <i>Object</i> is provided to keep
track of dependencies such as those between a model and its view.   This
mechanism uses an <i>IdentityDictionary</i> called <i>DependentFields</i>  (a
class variable of <i>Object</i>) which simply records all existing
dependencies.  The keys in this dictionary are all the objects that have
registered dependencies;  the value associated with each key is a list of the
objects which depend upon the key. In addition to this general mechanism, the
class <i>Model</i> provides a more efficient mechanism for managing dependents.
When you create new classes that are intended to function as active models in
an MVC triad, you should make them subclasses of <i>Model</i>.   Models in this
hierarchy retain their dependents in an instance variable (<i>dependents</i>)
which holds either nil, a single dependent object, or an instance of
<i>DependentsCollection</i>.  Views rely on these dependence mechanisms to
notify them of changes in the model.  When a new view is given its model, it
registers itself as a dependent of that model.  When the view is released, it
removes itself as a dependent.<p>
<p>
The methods that provide the indirect dependents communication link are in the
"updating" protocol of class <i>Object</i>.  Open a browser and examine these
methods.  The message <i>"changed"</i>  initiates an announcement to all
dependents of an object that a change has occurred in that object.  The
receiver of the <i>changed</i> message sends the message <i>update: self</i> to
each of it's dependents.  Thus a model may notify any dependent views that it
has changed by simply sending the message <i>self changed</i>.  The view (and
any other objects that are registered as dependents of the model) receives the
message <i>update:</i> with the model object as the argument.  [Note: There is
also a <i>changed:with:</i>  message that allows you to pass a parameter to the
dependent.] The default method for the <i>update: </i>message, which is
inherited from <i>Object</i>, is to do nothing.  But most views have protocol
to redisplay themselves upon receipt of an <i>update:</i> message.  This
<i>changed/update</i> mechanism was chosen as the communication channel through
which views can be notified of changes within their model because it places the
fewest constraints upon the structure of models. <p>
<p>
To get an idea of how this changed/update: mechanism is used in MVC, open a
browser on senders of the <i>changed</i> message (<i>Smalltalk
browseAllCallsOn: #changed</i>) and another on implementers of the
<i>update:</i> message (<i>Smalltalk browseAllImplementorsOf: #update</i>).
Note that nearly all the implementors of <i>update</i>: are varieties of
<i>View</i>, and that their behavior is to update the display.  Your views will
do something similar.  The senders of <i>changed</i> and <i>changed:</i> are in
methods where some property of the object is changed which is important to its
view.  Again, your use of the <i>changed</i>  message will be much like
these.<p>
<p>
An object can act as a model for more than one MVC triad at a time.  Consider
an architectural model of a building.  Let us ignore the structure of the model
itself.  The important point is that there could be a view of the floor plan,
another external perspective view, and perhaps another view of external heat
loss (for estimating energy efficiency).  Each view would have its cooperating
controller.  When the model is changed, all dependent views can be notified.
If only a subset of these views should respond to a given change, the model can
pass an argument which indicates to the dependents what sort of change has
occurred so that only those interested need respond.  This is done with the
<i>changed:</i> message.  Each receiver of this message can check the value of
the argument to determine the appropriate response.<p>
<p>
<H3>The View - Controller Link</H3>
<p>
<p>
Unlike the model, which may be loosely connected to multiple MVC triads,
Each view is associated with a unique controller and vice versa.  Instance
variables in each maintain this tight coupling.  A view's instance variable
<i>controller</i> points at its controller, and a controller's instance
variable <i>view</i> points at its associated view.  And, because both must
communicate with their model, each has an instance variable <i>model</i> which
points to the model object.  So, although the model is limited to sending
<i>self changed:,  </i>both the view and the controller can send messages
directly to each other and to their model.<p>
<p>
The View takes responsibility for establishing this intercommunication within a
given MVC triad.  When the View receives the message <i>model:controller:</i>,
it registers itself as a dependent of the model, sets its controller instance
variable to point to the controller, and sends the message <i>view: self</i> to
the controller so that the controller can set its <i>view</i> instance
variable.  The View also takes responsibility for undoing these connections.
View <i>release</i>  causes it to remove itself as a dependent of the model,
send the message <i>release</i> to the controller, and then send <i>release</i>
to any subViews.<p>
<H2><CENTER>Views</CENTER></H2>
<p>
<p>
<H3>The View/SubView Hierarchy</H3>
<p>
<p>
Views are designed to be nested.  Most windows in fact involve at least
two views, one nested inside the other.  The outermost view, known as the
topView is an instance of <i>StandardSystemView</i> or one of its subClasses.
The <i>StandardSystemView</i> manages the familiar label tab of its window.
Its associated controller, which is an instance of
<i>StandardSystemController</i>, manages the familiar moving, framing,
collapsing, and closing operations available for top level windows.  Inside a
topView are one or more subViews and their associated controllers which manage
the control options available in those views.  The familiar workspace for
example has a <i>StandardSystemView</i> as a topView, and a
<i>StringHolderView</i> as its single subView.  A subView may, in turn, have
additional subViews although this is not required in most applications.  The
subView/superView relationships are recorded in instance variables inherited
from <i>View</i>.   Each view has an instance variable, <i>superView</i>, which
points to the view that contains it and another, <i>subViews</i>, which is an
<i>OrderedCollection</i> of its subViews.  Thus each window's topView is the
top of a hierarchy of views traceable through the superView/subViews instance
variables.  Note however that some  classes of view (e.g., <i>BinaryChoiceView,
</i>and <i>FillInTheBlankView</i>) do not have label tabs, and are not
resizable or moveable.  These classes do not use the <i>StandardSystemView</i>
for a topView;  instead they use a plain <i>View</i> for a topView. <p>
<p>
Let's look at an example which builds and launches an MVC triad.  This example
is a simplified version of the code which opens a methodListBrowser -- the
browser you see when you choose the implementors or senders menu item in the
method list subView of a system browser.   The upper subView of this browser
displays a list of methods.  When one of these methods is selected, its code
appears in the lower subView.  Here is the code with lines numbered for easy
reference.<p>
<p>
<LISTING>
	openListBrowserOn: aCollection label: labelString initialSelection: sel
	"Create and schedule a Method List browser for the methods in aCollection."
	| topView aBrowser |
1.	aBrowser := MethodListBrowser new on: aCollection.
2.	topView := BrowserView new.
3.	topView model: aBrowser; controller: StandardSystemController new;
4.			label: labelString asString; minimumSize: 300@100.
5.   topView addSubView:
6.		(SelectionInListView on: aBrowser printItems: false oneItem: false
7.		aspect: #methodName   change: #methodName:   list: #methodList
8.		menu: #methodMenu   initialSelection: #methodName)
9.		in: (0@0 extent: 1.0@0.25) borderWidth: 1.
10.   topView addSubView:
11.		(CodeView on: aBrowser   aspect: #text   change: #acceptText:from:
12.			menu: #textMenu   initialSelection: sel)
13.			in: (0@0.25 extent: 1@0.75) borderWidth: 1.
14.   topView controller open

</LISTING>
<p>
Now let's look at this code line by line.  After creating the model [1], we
create the topView [2].  Usually this will be a <i>StandardSystemView</i>, but
here we use a <i>BrowserView</i>, which is a subClass of
<i>StandardSystemView</i>.  Line [3] specifies the model and controller.
[Note: If the controller is not explicitly provided, the
<i>defaultController</i> method of the view will provide the controller when
the view's controller is first requested.   Many applications specify the
controller indirectly in this default method rather than explicitly providing
the controller when the view is opened.]  The next line provides the topView's
label and minimum size [4].  Lines [5-9] install the upper subView, which is a
<i>SelectionInListView</i>.   The lower <i>CodeView</i> is installed by lines
[10-13].  Both of these types of view are known as "pluggable views."  These
are discussed in more detail in a later section.  Look closely at lines [9] and
[13] which indicate the placement of the subViews within the rectangle occupied
by the topView.  There are a variety of ways to indicate to a view how it
should place its subviews such as <i>addSubView:below:</i> and
<i>insertSubView:above:</i>.  They will be found in the subView inserting
protocol of <i>View</i>.  Here the placements are given relative to a canonical
1.0@1.0 rectangle.  Your code need not depend upon the final size and shape of
the topView window.  The upper view is placed at the upper left corner (i.e.,
at 0@0) and allowed to occupy the full width but only the top 25% of the height
of the topView (i.e. extent: 1@0.25).  The lower subView is placed at 0@0.25
and allowed to occupy the remainder of the window (1@0.75).  Each is given a
borderWidth of 1 pixel. Finally, the controller is opened [14] which causes the
window to initiate the framing process -- the cursor becomes the upper left
corner cursor so that the user can frame the window.    Your own MVC
applications will usually be opened similarly.<p>
<p>
<p>
<p>
<H3>Displaying Views</H3>
<p>
<p>
Your view may need its own display protocol.  This protocol will be used both
for the initial display of your view and for redisplay when the model signals a
change (and possibly for redisplay instigated by the controller as well).
Specifically, the <i>update:</i>  method in <i>View</i> sends <i>self
display</i>.  <i>View display</i>  in turn sends <i>self displayBorder. self
displayView. self displaySubviews.</i>  If your view requires any special
display behavior other than what is inherited, it belongs in one of these three
methods.  You can browse implementors of <i>displayView</i> for examples of
different sorts of display techniques.  If you do, you will note that several
display methods make use of display transforms.<p>
<p>
Display transforms are instances of <i>WindowingTransformation</i>. They handle
scaling and translating in order to connect windows and viewports.  A window is
the input to the transformation.  It is a rectangle in an abstract display
space with whatever arbitrary coordinate system you find most appropriate for
your application.   A viewport can be thought of as a specific rectangular
region of the display screen to which the abstract window should be mapped.
The class <i>WindowingTransformation</i> computes and applies scale and
translation factors on displayable objects such as points and rectangles so
that aWindow, when transformed, corresponds to aViewport.  However the
transformation simply scales and translates one set of coordinates to another
hence there is no necessary connection to the display screen; the
transformation could be used for other purposes.<p>
<p>
<i>WindowingTransformation</i>s can be composed, and their inverses can be
invoked.  Views use transformations to manage subview placement.  You too can
use them if you need to draw directly in a view.  <i>View displayTransform:</i>
anObject applies the display transformation of the receiver to anObject and
answers the resulting scaled, translated object.  It is usually applied to
Rectangles, Points, and other objects with coordinates defined in the View's
local coordinate system to obtain a scaled and translated object in display
screen coordinates.  The <i>View displayTransformation</i> returns a
<i>WindowingTransformation</i> that is the result of composing all local
transformations in the receiver's superView chain with the receiver's own local
transformation.  <i>View inverseDisplayTransformation: aPoint</i>  is used by
controllers <i>redButtonActivity</i> to convert aPoint (e.g., Sensor
cursorPoint) from screen coordinates to view's window coordinates.<p>
<p>
<H3>Notes on Existing Views</H3>
<p>
<p>
Your first application views will begin with existing views,  an annotated list
of which appears at the end of this section.  Some of these, such as browsers
inspectors and debuggers are complete applications which you can use as
examples.  Others are general purpose views which you will use intact as
subviews in your applications.  Some you will no doubt want to refine by
creating subclasses with more specialized behavior.   Much can be learned about
making use of a given view by simply browsing the view creation methods that
make use of the view.  For example, executing <i>Smalltalk browseAllCallsOn:
(Smalltalk associationAt: #SwitchView)</i> will present you with a method
browser on all methods which send messages to class SwitchView.   Among these
will be instance creation methods of other views which use the given view as a
subview.  You can use these as examples of how to do so yourself. <p>
<p>
Four of the general purpose existing views -- <i>BooleanView</i>,
<i>SelectionInListView</i>, <i>TextView</i> and <i>CodeView --</i> are
especially flexible.  These are called "pluggable views."  Their extra
flexibility is designed to reduce the need for many subclasses which differ
only in the method selectors used to do common tasks such as obtain data from
the model or present a different <i>yellowButtonMenu</i>.  Pluggable views and
their associated controllers perform these tasks by invoking "adaptor"
selectors passed to them at the time of instance creation.  The
<i>SelectionInListView</i> and <i>CodeView</i> used as subviews in the
<i>openListBrowserOn:  </i>method<i> </i>shown in an earlier section are
examples.  Note that the arguments passed to the creation methods of these
views are selector names.  The class comment of each pluggable view defines the
selectors to be passed to that view.<p>
<p>
<p>
<H3>The Existing View Hierarchy</H3>
<p>
<p>
<LISTING>View - used as nonstandard topView for BinaryChoiceView and FillInTneBlankView
	BinaryChoiceView - the thumbs up/down prompter
	SwitchView - used in BitEditor and FormEditor as tool buttons
		BooleanView - [pluggable] used for browser instance/class switch
	DisplayTextView - used for message in the upper subview of a yes/no prompter
	TextView - [pluggable] not used in vanilla V2.5 image
		CodeView - [pluggable] used for browser subview which shows code
			OnlyWhenSelectedCodeView - used by FileList lower subview
	StringHolderView - used by workspaces
		FillInTheBlankView - the familiar question prompter with a text answer
		ProjectView - description view of a project
		TextCollectorView - used by the Transcript
	FormMenuView - used by BitEditor and FormEditor for buttons
	FormView - used by BitEditor and the background screen gray InfiniteForm
		FormHolderView - used by BitEditor and FormEditor for edited form
	ListView - not used in vanilla V2.5 image
		ChangeListView - a complete application
		SelectionInListView - [pluggable] used for browser list subviews
	StandardSystemView - provides topView functions
		BrowserView - complete applications
		InspectorView - complete application
		NotifierView - error notifier, e.g., "Object does not understand"
</LISTING>

<H2><CENTER>Controllers</CENTER></H2>
<p>
<p>
Smalltalk-80 presents the appearance that control resides in the mouse.  As one
moves and clicks the mouse, the objects on the Smalltalk-80 screen perform much
as an orchestra obeying its conductor.   But there is, in fact, no single
autocratic power.  A single thread of control is maintained by the cooperation
of the controllers attached to the various active views.  Only one controller
can actually have control at any one time.  So the trick is to make sure it is
the proper one!<p>
<p>
<H3>Communication Between Controllers</H3>
<p>
<p>
The primary organizing principle which makes this trick possible is that the
active controllers for each project form a hierarchical tree.   At the root of
this tree is the global variable <i>ScheduledControllers</i>, which is a
<i>ControlManager</i> attached to the active project.  Branching from
<i>ScheduledControllers</i> are the topLevel controllers of each active window,
plus an additional controller which manages the main system
<i>yellowButtonMenu</i> available on the grey screen background.  Since each
view is associated with a unique controller, the view/subView tree induces a
parallel controller tree within each topView.  Further branches from each
topLevel controller follow this induced  tree.  Control passes from controller
to controller along the branches of this tree.<p>
<p>
In simple terms the control flow requires the cooperative action of  well bred
controllers each of which politely refuses control unless the cursor is in its
view.  And upon accepting control the well bred controller attempts to defer to
some subView's controller.  The top level <i>ControlManager</i> asks each of
the controllers of the active topViews if it wants control.  Only the one whose
view contains the cursor responds affirmatively and is given control.  It, in
turn,  queries the controllers of its subViews.  Again  the one that contains
the cursor accepts control.  This process finds the innermost nested view
containing the cursor and, in general, that view's controller retains control
as long as the cursor remains in its view.  (A more detailed  exposition of
this control flow appears in Appendix A.)  In this scheme, control management
involves the cooperation of <b>all</b> the active views and controllers in an
intricately coordinated minuet.  Views are required to poll the controllers of
their subViews.  Controllers ask their views if they contain the cursor.  For
that reason, it is unusual -- and risky -- to make modifications to your views
or controllers  that involve nonstandard flow of control.  Keep this firmly in
mind when you first attempt to install a new application controller because
inadvertent disruption of the flow of control will crash the system.  The
prudent programmer  does a snapshot before making the attempt!<p>
<p>
The vital role played by controllers implies that you cannot have a model-view
pair without a controller.  If that were allowed, the flow of control would
disappear in the gap left by the missing controller.  Yet there are some cases
where you might want  a set of subViews to be controlled collectively from the
containing controller, rather than from the individual controllers of the
subViews.   A special controller for such subViews is provided by the class
<i>NoController</i>  which is specifically constructed to refuse control.<p>
<p>
The dance of the scroll bars among the browser subviews as the cursor moves
between them is the most visible consequence of the flow of control.  As the
cursor crosses boundaries of subViews within the browser the scroll bar of the
just exited subView disappears and the scroll bar for the entered subView
appears.  This is accomplished by the <i>controlInitialize</i> and
<i>controlTerminate</i> methods of those subViews with controllers that inherit
from <i>ScrollController</i>.  When the cursor exits a given subView,
<i>viewHasCursor</i> returns false,  and the controller executes its
<i>controlTerminate</i> method which redisplays the area previously covered by
the scroll bar.  Then the appropriate portion of the view/control tree is
traversed to find the controller which should now have control.  If this view
should have a scroll bar, the <i>controlInitialize</i> method of the new
controller saves the display area that is to be covered by the scroll bar, then
displays the scroll bar.<p>
<p>
<H3>Entering and leaving the flow of control</H3>
<p>
<p>
Remember that this minuet of manners is a constantly ongoing one.  How then
does your newly created MVC triad step into the process, and how does it retire
when it is done?<p>
<p>
First, the controller of your topViews is the one responsible for entering this
process.  It then passes control to its subView controllers (which in reality
do most of the work in a typical application).  The top level controllers must
all be descendants of the class <i>StandardSystemController</i> which is
designed to be the controller of a top level view.  The <i>open </i>message to
a standardSystemController causes your new MVC to become a top level branch of
the control tree.  The <i>open</i> message should be the last message in the
method which creates the new MVC because control does not return from this
message.  Code appearing after the <i>controller open</i> message will not be
executed.    The <i>controlTerminate</i> method of a
<i>StandardSystemController</i> takes responsibility for unscheduling  when the
window is closed.<p>
<p>
<p>
<H3>The MouseMenuController</H3>
<p>
<p>
Most applications use the mouse for pointing and menu options.  Most
controllers are therefore installed somewhere in the class hierarchy under
<i>MouseMenuController</i> which provides the basic instance variables and
methods.  The relevant instance variables are <i>{red, yellow,
blue}ButtonMenu</i> and <i>{red, yellow, blue}ButtonMessages</i> in which you
will install your menus and their associated messages.  The important methods
are <i>redButtonActivity</i>, <i>yellowButtonActivity</i>, and
<i>blueButtonActivity</i>.  The <i>Controller controlLoop</i> method, as its
name implies, is the main control loop.  Each time through this loop, it sends
<i>self controlActivity</i>.  This method is reimplemented in
MouseMenuController to check each of the mouse buttons and, for instance, send
<i>self redButtonActivity</i>  if the red button is pressed and its view has
the cursor.  The xxxButtonActivity checks for a non nil xxxButtonMenu, and if
found, sends the message: <i>self menuMessageReceiver perform:
(redButtonMessages at: index).  </i>Note: <i>menuMessageReciever</i> normally
returns self -- i.e., the controller -- so that menu message protocol normally
resides in the controller.<p>
<p>
All top level controllers are instances of <i>StandardSystemController</i> or
its subclasses.  The <i>StandardSystemController</i> is a subclass of
<i>MouseMenuController</i>, which is specialized for being at the top level of
a window's controller hierarchy.  It manages the familiar blueButtonMenu -- the
frame, close, collapse, . . . behavior of windows -- which apply to the
topView.  Your subview controllers should <b>not</b> be subclasses of
<i>StandardSystemController</i>.  Rather, they should descend separately from
<i>MouseMenuController</i>.  Yet the blueButton menu functions should still be
handled by the topLevel controller.  To ensure this your controller can reroute
a blueButton press to the top level by the following blueButtonActivity
method:<p>

<LISTING>

	blueButtonActivity
	view topView controller blueButtonActivity.

</LISTING>

This is most transparent in that a person browsing your controller code can
immediately see that the blueButton is being handled by the topView controller.
A more subtle approach is for the subView controller to refuse control if the
blueButton is down.  This is done in your <i>isControlActive  </i>method:<p>
	
<LISTING>

	isControlActive
	^super isControlActive & sensor blueButtonPressed not.

</LISTING>

<p>
In the typical case, your controller will have its own <i>yellowButtonMenu</i>,
and perhaps use the red button for some sort of pointing or item selection
function.   You will usually make your menus something like the following: <p>
<LISTING>

		PopUpMenu labels:
		'foo baz
		over there
		file out
		new gadget'
			lines: #(1 3).

</LISTING>
This provides a menu with the given options, and with lines after the first and
third items.  You then install a parallel list of messages, e.g., <i>#(fooBaz
overThere fileOut newGadget)</i>.  The menu and the messages list must end up
in the yellowButtonMenu and yellowButtonMessages instance variables.  This can
be done on the fly if desired, but the more typical approach is to build the
menu and messages in a class initialize method and install them in the instance
initialize method.  For an example, look at the <i>ChangeListController class
initialize</i> method.  Finally, you need to install the methods to implement
the menu messages.  They conventionally reside in the <i>menu messages</i>
protocol of your controller.  If you wish to use redButton presses for control
activity other than menu selection, redefine the <i>redButtonActivity</i> of
your controller to implement the desired activity.  In your new
redButtonActivity method you can check for other conditions such as <i>Sensor
leftShiftDown</i> to provide more flexibility.  You can see examples of nonmenu
<i>redButtonActivity</i> methods in the <i>FormEditor</i>,
<i>ListController</i>, and <i>SelectionInListController</i>.<p>
<p>
Menus, despite their use of the display screen, are not handled by MVC triads.
They manage their own screen display and control, including the saving and
replacing of the screen contents in the region covered by the menu.  In
addition to the PopUpMenu in the above example, you should examine ActionMenu
which is especially useful for pluggable views.<p>
<p>
<H3>ParagraphEditor</H3>
<p>
<p>
All controllers that accept keyboard text input are under the
<i>ParagraphEditor</i> in the <i>Controller</i>  hierarchy.<b>
</b><i>ParagraphEditor</i> predates the full development of the MVC paradigm.
It handles both text input and text display functions, hence it is in some ways
a cross between a view and a controller.  The views which use it or its
subcasses for a controller reverse the usual roles for display; they implement
the display of text by sending <i>controller display.</i>   The multiplicity of
roles played by the <i>ParagraphEditor</i> make it a complex object.   It
manages the special keys (for example, the Ctrl T mapping to <i>ifTrue:</i>).
It also manages the selection of text, the selection of font and point size,
and the formatting of the text (that is, proportional character spacing and
line breaks tailored to the width of the view).   Because it is at the top of
the hierarchy of text handling controllers,  you have easy access to all of
it's power.  But the complexity of the text processing classes carries a
substantial overhead penalty.  This overhead is most visible in the annoying
delay between the typing of a character and its display on the screen.  The
three classes that do most of the text prossesing work are
<i>ParagraphEditor</i>, <i>Paragraph</i>, and <i>CharacterScanner</i>.  Some
Smalltalk-80 programmers have created  parallels to each of these classes that
dispense with most of the time consuming features.  They have achieved text
processing speeds for specialized applications that are several times faster
than that provided by the standard classes.<p>
<p>
<H3>ScreenController</H3>
<p>
<p>
The gray screen background and the yellowButtonMenu available on that
background are not special exceptions to the MVC paradigm; they too are managed
by an MVC triad.  The model is an <i>InfiniteForm</i> (colored gray), the view
is an instance of <i>FormView</i>, and the controller is the single instance of
class <i>ScreenController</i>.  To add an item to the main screen menu (perhaps
a printScreen option), you edit the <i>ScreenController</i> class method
<i>initialize</i> (in the class initialization protocol) and add your method in
the menu messages protocol.  Don't forget to execute the comment at the bottom
of the class initialize method to install your new menu.   You might also wish
to look at the other methods in the menu messages protocol to see how browsers,
file lists, or workspaces are opened.<p>
<p>
<H2><CENTER>The MVC Inspector</CENTER></H2>
<p>
<p>
Because the MVC triad is so important, Smalltalk-80 provides a specialized
inspector -- an MVC inspector -- to examine all three objects at once.  You
will likely make considerable use of this inspector when you begin to build
your own applications both as a tool for seeing how other MVC triads work and
as an invaluable debugging aid to see why your own doesn't work.  You open an
MVC inspector by sending the message <i>inspect</i> to any View.  The easiest
way to make use of MVC inspectors is to fileIn the BLUEINSP.ST goodie provided
with the Smalltalk-AT distribution. [Note: not all distributions of
Smalltalk-80 include this goodie.]  It installs a blue button menu item
"inspect" for all topViews.  This menu item opens an MVC inspector on the view,
its model and its controller.  Once you understand a bit about the MVC triad,
the MVC inspector will let you poke about in the innards of any window which
catches your fancy.  In a complex view such as a browser, with many subviews,
you can follow the chain of subViews down, opening further MVC inspectors on
selected subViews.<p>
<p>
As an exercise, open an MVC inspector on the System Transcript window (first be
sure a SystemTranscript is open on your screen).  Begin by opening an inspector
on the instances of <i>DependentsCollection</i> by executing
<i>DependentsCollection allInstances inspect.</i>   Locate the item with two
dependents: "a <i>StandardSystemView</i>" and "<i>aTextCollectorView</i>."
Select the <i>TextCollectorView</i> and choose inspect.  Now you will have an
MVC inspector on the <i>TextCollector</i>, its view, and its controller.   For
instance, in the top model subview, select the <i>contents</i> variable:  in
the right window, you will see the same text as you see in your Transcript
window.  In the bottom controller section look at and inspect the button menus
and messages.  They will be the familiar ones of the transcript.  In the middle
view section, select superView: it will be a <i>StandardSystemView</i>.  Select
it and choose inspect.  You will then have another MVC inspector on the topView
of the transcript window.  These two MVC inspectors together give access to the
entire structure of the transcript application.  Note, both MVC triads share
the same model -- the <i>TextCollector</i> .<p>
<p>
[Note: In versions of Smalltalk-80 prior to the inclusion of the <i>Model</i>
class, you will need to start differently: begin by opening an inspector on the
<i>DependentsFields</i> dictionary (the dictionary in which all  object
dependencies are maintained)  by executing <i>(Object classPool at:
#DependentsFields) inspect.</i>  This gives you access to an inspector on the
<i>IdentityDictionary</i>.  Locate the item with the key "aTextCollector,"
which is the model of a transcript.  Select it and choose the inspect option in
the yellowButtonMenu.  This opens an inspector on the <i>OrderedCollection</i>
of objects registered as dependents of the <i>TextCollector.</i>  In this new
inspector, one of the items will be a <i>TextCollectorView</i>.  Select the
<i>TextCollectorView</i> and choose inspect. ]<p>
<H2><CENTER>Appendix A:</CENTER></H2>
<p>
<H3><CENTER>Details on the flow of control</CENTER></H3>
<p>
<p>
Above all of the controllers of topViews is <i>ScheduledControllers</i> -- the
instance of <i>ControlManager</i> attached to the current project.  This
controlManager determines which of the topView's controllers should be active.
It uses the method <i>searchForActiveController</i>, which in turn sends
<i>isControlWanted</i> to all scheduledControllers.  When it finds the
appropriate top level controller it sends that controller the message
<i>startUp</i>, which is inherited from class Controller.  It sends the
following three messages: <i>self controllInitialize, self controlLoop, self
controlTerminate</i>.  The <i>controllLoop</i> method handles the flow of
control by:<p>
<LISTING>
	[self is ControlActive] whileTrue: [Processor yield.
  self controlActivity]
</LISTING>

<i></i>The <i>self controlActivity</i>  just says: <i>self
controlToNextLevel</i>.  Here the control flow is passed briefly to the view by
means of the code:<p>

<LISTING>	
	aView := view subViewWantingControl.
	aView ~~ nil ifTrue: [aView controller startUp]
</LISTING>

which just asks the view to determine which of its subviews wants
control, and if one does, passing control to that view's controller.  The
<i>isControlWanted</i> method simply returns the result of the message <i>self
viewHasCursor</i> which in turn simply says <i>view containsPoint: sensor
cursorPoint</i>.  Thus, at the bottom of the flow of control process is the
question of which view contains the cursor.  The one exception is
<i>NoController</i> which reimplements <i>isControlWanted</i> to always return
false.<p>
<hr>
Thanks to <a href=mailto:clloyd@giantleap.com>Charles Lloyd</a> for
HTMLizing this document.
<hr>
<a href=/><img src=/users/smarch/pics/smalltalk-archive.gif
alt="[Smalltalk Archive]" border=0></a>
<a href=/research-gp.html><img src=/users/smarch/pics/research-group.gif
alt="[Research Group]" border=0></a>
<a href=/users/chai/locator.html><img src=/users/smarch/pics/contact-ian.gif alt="[Contact Ian]" border=0></a>
<a href=/users/chai/main.html><img src=/users/smarch/pics/home.gif alt="[Ian's Home]" border=0></a>
<a href="ftp://st.cs.uiuc.edu/pub/Smalltalk/st-docs/mvc.rtf"><img src=mvc-button.gif border=0 alt="[Original RTF of this document]"></a>
<img src=mvc.dategif alt="" align=right>
<br>If you spot an error, please contact Ian.
</body>
</html>
